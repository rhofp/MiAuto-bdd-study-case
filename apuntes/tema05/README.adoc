= Tema 5
Creado por Rodrigo Francisco <rhodfra@gmail.com>
Version 1.0, 10.11.2020
:description: Semana 08 del curso de CCNA
:keywords: cnna, switching, stp, spanning tree protocol  
:sectnums: 
// Configuracion de la tabla de contenidos
:toc: 
:toc-placement!:
:toclevels: 4                                          
:toc-title: Contenido

// Ruta base de las imagenes
:imagesdir: ./README.assets/ 

// Resaltar sintaxis
:source-highlighter: pygments

// Iconos para entorno local
ifndef::env-github[:icons: font]

// Iconos para entorno github
ifdef::env-github[]
:caution-caption: :fire:
:important-caption: :exclamation:
:note-caption: :paperclip:
:tip-caption: :bulb:
:warning-caption: :warning:
endif::[]

Optimización de Consultas Distribuidas

toc::[]

== Características del optimizador centralizado

=== Estimador

* Si no hay estadísticas, puede usar
** Histogramas

=== Generador del plan de ejecución

Las operaciones JOIN son de las más costosas en un plan de ejecución, sobre todo 
donde hay múltiples tablas.

* Puede ser más eficiente una combinación de tablas que otra
* Del lado de los ususario no importa lo siguiente

[source,sql]
----
-- No importa la conmutatividad
a join b join c 
b join a join c

-- Lo siguiente no afecta el desempeño
a join b
-- Por medio de la sintaxis estandar
on a.id = b.id
-- Por medio de la sintaxis anterior
where a.id = b.id
----

Otra fuente de datos del usuario son los *índices*, por ejemplo:

`select cliente_id from cliente`

Esta consulta utiliza únicamente los índices. No necesitamos tocar 
la tabla.

Lo anterior se mejor porque de otra manera tendríamos que cargar toda
la tabla a memoria.

Vamos a tener 2 métodos de acceso a datos (Access Path)

* A la tablas
* A la índices

Para el curso y con el manejador Oracle solo utilizaremos

* Tablas
* índices B-Tree

//-
image::indices.png[]

Métodos para ejecutar operaciones JOIN

* Nested Loop Joins
* Has Joins
* Sort merge Joins
* Cartesian Joins

El tipo de Join puede influenciar al optimizador en especial para
determinar el orden correcto  de ejecución.

== Optimización de consultas centralizados - Oracle

Bloque SQL ::
Cada instrucción select representa un bloque

La selección del plan de ejecución se ve afectado por: 

* La forma de escribir la consulta
* El tamaño de conjunto de datos
** Si no tiene índices el desempeño baja
** Si tenemos una tabla _gigantesca_, ¿cómo le ayudamos a mejorar el
desempeño?
+
image:optim.png[]

//-

[NOTE]
====
Terminología útil

image::notatns.png[]
====

=== Plan de ejecución

Me dice el impacto que tendría ejecutar cierta sentencia. Se ve más
o menos así

image::plan.png[]

Id:: El identificador de cada operación
Operacion:: Entran en juego los métodos de acceso
Name:: Fuente de datos (tabla o índice)
Rows:: Número de registros estimado a obtener
Bytes:: Memoria que vamos a utilizar
Cost:: Costo de la consulta
Time:: Tiempo de procesamiento

Las estadísticas nos dicen se debemos usar la tabla o le índice. Si hay pocos
registros entonces le convendrá cargar toda la tabla a memoria.
_Se debe tener las estadísticas actualizadas_, en caso de ORACLE, las 
estádisticas se recolectan en automático.

En proceso no es 100% confiable por ello podemos hacerlo de forma manual

[source,sql]
----
begin
  dbms_status.gather_schema_stats (
    ownname => 'CONTROL_MEDICO', #<1> 
    degree => 2 #<2> 
  );
end;
/
----
<1> Todas las tablas que estan en el esquema
<2> 2 hilos ejecucion

Hay dos formas para obtener un plan de ejecución. Suponer la siguiente consulta

[source,sql]
----
explain plan 
set statement_id = 's1' for #<1>
select m.nombre, c.fecha_cita
from medico m, cita c
where m.medioc_id = c.medico_id
and consultorio='C-593'
----
<1> Es opcional

Los planes de ejecución se pone en PLAIN TABLE

Para mostrar el plan de ejecución

[source,sql]
----
set linesize 100
select plan_table_output
from table(dbms_xplan.display('PLAN_TABLE','s1'm'TYPICAL)); #<1>
----
<1> De typical indica el nivel de explicacion que se mostrará

Para aplicar un NESTED LOOP se requerieren 2 operaciones.
Es uno de los parametros de otro NESTED LOOP (el mas externo), sus parámetros
son NESTED LOOP (interno) y TABLE ACCESS.
El NESTED LOOP (externo) será ocupado por el SELECT

Hay métodos de acceso a tablas y a índices

.Métodos de acceso, algunos ejemplos
* Escanear toda la tabla
* Escaneo por _row_id_

[NOTE]
====
El *row_id* me dice la localización precisa en disca de una dato
====


El manejador internamente puede hacer join entre índices

Organización de tablas

*Heap Organized table (Default)* ::
No hay orden por defecto la hora de guardar la tabla
*Index Organized table* ::
Los registros se orden con respecto a su PK


==== Acceso a tablas

.Hay dos métodos de acceso
* Table Access Full 
+
image::accessfull.png[]
Gastaría mucha memoria y puede que mi tabla no quepa en
el buffer *(Se deben leer todos los bloques de datos)*
+ 
*OJO*: Los indices no se llevan bien con los valores nulos
+ 
image::findex.png[] 
El índice no se usará. +
El índice no se usará si se quiere cargar toda la tabla.
En tablas pequeñas se hará un _table access full_
** Si la tabla tiene menos de 128 bloques.
* Podemos forzar al optimizados a hacer un table access full
** Se realiza por medio del _hint_, es una pista u orden.
** En términos de sintáxis se ve como un comerario
+
[source,sql]
----
/*CONSULTA*/
----

[WARNING]
====
Dada una consulta debemos saber que método de acceso se ocupará
====

*Ejemplo*

[source,sql]
----
explain plan for
select * from paciente;

select plan_table_output
from table (dbms_xplan.display); # <1> <2>
----
<1> Por default utiliza plan_table
<2> Va a traer la última instruccion que haya solicitado el plan

.Explicación
* Se lanza un table acces full
** Debido a que se requieren todos los atributos

===== Table Access by row id

Los datos de entrada son los _row id_

Algoritmo::
    . Se consultan los índices para obtener los _row id_ 
    . y posteriormente se usa el _row id_ para ir al registro.
    
====
*Ejemplo 1:*

[source,sql]
----
explain plan for
select nombre
from paciente
where paciente_id = 3;      // <1>

select plan_table_output
from table(dbms_xplan.display);
----
<1> Se usará el indice y nos dirá el _row id_ de este registro

//-

. Se recupera el _row id_
. Con el _row id_ voy al bloque de datos para traer el registro.

====

===== Sample table scan

Se usa más de manera interna que a nivel de usuario final.

Se obtiene una muestra de un tabla, sin cargar toda la tabla.

* La muestra deseada se expresa en porcentaje
** El porcentaje se aplica a los bloques.

La sintaxis para provocar un sample table scan es:

[source,sql]
----
explain plan for
select *
from cita sample block(10);
select plan_table_output
from table(dbms_xplan.display);
----

===== In memory table scan

Obtener registros de una tabla almacenados en memoria en forma
columar: [underline]#IM Column Store#

image::inmemory.png[]

==== B-Tree Index Access Paths.

===== Index Unique scan.

* A lo más se regresa un id
* Si se aplica depende de la sentencia
** Generalmente cuando tenemos el signo de igualdad

====
¿Por qué no se usa el indice?

[source,]
----
explain plan for
select email
from paciente;
select plan_table_output
from table(dbms_xplan.display);
----


Por que el email es nulo. Los índices B-Tree no permite nulos.
Por lo tanto si se usa el índice se traerían un número 
erróneo de datos

Para que use el email
====

===== Index Range scan

Ejemplo

[source,]
----
explain plan for
select email
from paciente
where email like 'bob@%'
order by email desc;
select plan_table_output
from table(dbms_xplan.display);
----

Ejemplo 2: 

¿Por qué no se usa el índice?
[source,sql]
----
create index paciente_nombre_idx
on paciente(nombre);
explain plan for
select nombre
from paciente
order by paciente_id desc;
select plan_table_output
from table(dbms_xplan.display);
----

El índice nombre no es tan compatible con lo que queremos obtener (ver el caso del ordenamiento)

===== Index Full Scan

* Hace un escaneo completo de toda la columna indexada. 
Trayendo todos los _row id_

* Todas las columnas solicitas deben estar indexadas.
* Al menos una de las columnas esta decladad como 
[underline]#not null#

Ejemplo

[source,]
----
explain plan for
select nombre
from paciente
order by nombre;
select plan_table_output
from table(dbms_xplan.display);
----

===== Index Fast full scan

Los indices se almancenan como las tablas (en bloques).

Para ese tipo de indices se cargan los bloques de datos que contienen al indice en memoria.

Ejemplo 

[source,]
----
explain plan for
select email
from paciente
where email is not null;
select plan_table_output
from table(dbms_xplan.display);
----

No tiene la sentencia `order by` por lo tanto no se requiere
ordenamiento. No es necesario contruir el árbol.

===== Index Skip Scan

Pensemos en lo siguiente

image::indices2.png[]


En la segunda consulta no se va utilizar el indice que creo
porque al crear el índice si importa el orden.

* Atributos que tenga baja variedad debe ir al final.
* Debo incluir la columna uqe siempre se va a incluir en algún
predicado.
* Los atributos que sean unique debe ir al inicio. 

Ahora sí, hablemos sobre el método de acceso, _index skip
scan_ se utilizará sí

* La primera columna tiene muy pocos valores diferentes.
* La segunda columna tiene una gran cantidad de valores 
distintos.
* La consulta no incluye en el predicado a la primera columna.

Es decir quedaría algo así

image::indice-mal.png[]

Si se piden los correos no se utilizará el índice, 
_¿Qué podemos hacer?_

Suponer que se tiene lo siguiente

[source,sql]
----
create index unique paciente_gen_email_uk(genero, email)

select * from
paciente where email = 'yang@...';



// El manejador lo que hace para solucionar lo anterior 
es:

( select *
    from
    paciente
    where genero = 'F'
    and
    email = 'abbey@company.com' )
union all
    ( select *
    from
    paciente
    where genero = 'M'
    and
    email = 'abbey@company.com' )
----

[NOTE]
====
Si son demasiados valores distintos el manejador se irá por
el *full access table*
====

[NOTE]
====
Los _row id_ obtenidos se puede procesar en batch, por lote,
porque el manejador va a indentificar los bloques donde 
se encuentran los _row ids_ y se va a traer todo el bloque.
En lugar de ir uno por uno.

image::batch.png[]
====

===== Index Join scan

Aplica un Join entre indices.

Existen consultas que involucran 2 atributos indexados por
separado. Por ejemplo

[source,sql]
----
create index paciente_nombre_idx
on paciente(nombre);
create index paciente_ap_paterno_idx
on paciente(ap_paterno);
explain plan for
select nombre,ap_paterno
from paciente
where nombre like 'A%';
select plan_table_output
from table(dbms_xplan.display);
----

.Plan de ejecución
[width="100%",options="header,footer"]
|====================
| Método de acceso | Fuente de datos  
| * Hash Join        | 
| **  Index Full Scan  | paciente_ap_paterno_idx
| **  Index Range Scan |  paciente_nombre_idx 
|====================

El contenido _index range scan_  hasta ahora es 

image::index-join.png[]

Observar lo que tenemos

image::index-join2.png[]

[source,sql]
----
select q2.nombre, q1.ap_pat
from q1, q2
where q1. row_id = q2.row_id
----

== Joins
//TODO:- Agregar driven table

=== Nested Loop

* Tablas de tamaño mediado
* Se piensa de manera similar a un for anidado

=== Hash Join

._Algoritmo_
* buscar la tabla con la menor cardinalidad.
* EN el plan de ejecución se utiliza la primera tabla del 
plan de ejecución para construir la tabla hash

=== Sort Merge join

* Las columnas que nos sirven para el join debe estar ordenadas
